---
layout: post
title:  "Tree Recovery by Dynamic Programming - Project Page"
date:   2024-05-08 21:10:10 -0500
categories: jekyll update
---

This is a project page for the benefit of anyone who is interested in the problem of Tree Recovery. For reference, here are some resources: 
* The paper for the first part of the method can be found [here](https://ieeexplore.ieee.org/document/10197214). 
* The Python code associated to this part of the first part of the method can be found [here]().
* A faster, C++ version of the code that addresses both parts 1 and 2 can be found [here](). The datasets are also in this GitHub page. 

# Overview

Tree-like structures are common, naturally occurring objects that are of interest to many fields of study, such as plant science and biomedicine. Analysis of these structures is typically based on skeletons extracted from captured data, which often contain spurious segments or cycles that need to be removed. As such, recovering an acyclic, connected tree from this data is crucial for analyzing the underlying tree like structure. Therein lies our contribution, as seen in the following figure, which illustrates the general pipeline of tree reconstruction from the input data: 

![Foto](/assets/thesis/tree-recovery-pipeline.png){: width="500" }

There are several challenges with regards to recovering trees from noisy, cyclic graphs. Firstly, *multiple nodes in the input graph may be merged together*. This can often happen in 2D images when branches cross over each other, since we are looking at a 2D projection of a 3D object. This is illustrated in the following figure, where we can see merged nodes in a rice root image and a retinal fundus image: 

![Foto](/assets/thesis/projection-challenge.png){: width="500" }

A second challenge is the presence of *redundant nodes and edges* in the cyclic graphs. Noise in the input data or errors in the skeletonization process may often create redundant nodes and edges in the cyclic graphs. This problem may also present cycles in the input graph. In the graph below, you may see a graph obtained from a point cloud captured from a grapevine tree. Highlighted is the actual tree we want to obtain. As you can see, there are several nodes and edges that are **not** highlighted, and as such should not be included in the recovered tree: 

![Foto](/assets/thesis/noise-challenge.png){: width="500" }

Finally, we have the challenge of *labelling data*. It is often not enough to provide a tree. Often times we instead want to label the edges of the tree as well. For example, grapevines follow a strict hierarchy with trunks, support, and leader branches that should be labelled. Furthermore, on retinal datasets, we often want to provide two trees: one where the edges are labelled as arteries, and another where the edges are labelled as veins. This is a challenge because these labels have to adhere to domain-specific constraints. For instance, the grapevine's hierarchy has to adhere to a specific progression that cannot be violated. Furthermore, the labels will often times determine what the tree structure should look like. This means that any tree recovery method must simultaneously optimize for the tree and the labelling of the edges, rather than obtaining a tree, and then labelling the edges. The following figure illustrates an example labelling of a grapevine tree, and an example labelling of blood vessels:

![Foto](/assets/thesis/label-challenge.png){: width="500" }

This work is subdivided into two parts: firstly, we have a tree recovery method, published in IEEE Transactions on Pattern Analysis and Machine Intelligence, that addresses the first challenge by duplicating nodes. Secondly, we have an extension of this method that addresses the remaining two challenges by removing edges, nodes, and labelling edges. The entirety of this project is currently being submitted as my doctoral thesis. 

![Foto](/assets/thesis/recovery-parts.png){: width="500" }

# Part 1

The paper corresponding to this part of the project can be found [here](https://ieeexplore.ieee.org/document/10197214). 

The idea is as follows. Given a node of a graph, we can decompose its edges into multiple groups by duplicating the node. We may also assign directions of the surrounding edges. For the purpose of this project, we call this decomposition/direction combinations *node partitions*. Examples of this can be seen in the following figure:

![Foto](/assets/partition-examples.png){: width="500" }

If we assign costs to each partition, and carefully design constraints such that the graph results in a tree, we are left with an optimization problem to obtain a tree from a cyclic graph. We can see this in the following picture, where we split the nodes of an retinal fundus image to obtain a tree: 

![Foto](/assets/tree-recovery.png){: width="500" }

The problem of finding an optimal tree this way is NP-Hard. As such, we have two contributions for this part:
1. We design an optimal, Dynamic Programming algorithm to obtain a tree from a noisy graph by partitioning the nodes. This method is faster than competing methods for small to medium-sized graphs. 
2. We design an approximation method that sacrifices optimality for efficiency. This method is still more optimal than competing methods, and is fast for larger graphs, as well. 

# Part 2

The work corresponding to part 2 can be found in my thesis, which is currently in the process of being submitted. 

Here we address all of the afforementioned challenges: merged nodes, redundant edges/nodes, and labelling edges. We can see an example of our results in the following figures:

![Foto](/assets/part-2-example.png){: width="500" }

We achieve this by allowing partitions of a node to omit any amount of edges. The omission of all edges results in the omission of the node itself. We also allow partitions to contain labels for each of the node's adjacent edges. Finally, we can toggle whether we want to allow for the removal of edges, the duplication of nodes, or the existence of edge labels. 

An example of this can be seen in the following image, where we allow for node duplication, and labelling edges as arteries or veins. Note that arteries and veins cannot share the same node. This is why the bottom-left partition is marked in red, as it is invalid: 

![Foto](/assets/partition-av-examples.png){: width="500" }

In the following example, used for the grapevine dataset, we do not allow for node duplication, but do allow for edge omission. Also note that edges labelled as "trunk" must lead to edges labelled as "support," which is why the bottom left partition is marked in red as invalid: 

![Foto](/assets/partition-grapevine-examples.png){: width="500" }

We finally provide a semi-automatic method to fix resulting trees, in case the algorithm couldn't find an ideal reconstruction. The idea is that the user can manually select any contraint for any node in the graph. The dynamic programming algorithm will then efficiently re-run and find a solution for the given constraints: 

![Foto](/assets/semi-auto-example.png){: width="500" }

# Future Works

This is a continuing work. As such, there are many potential extensions to our method. 

## Improving the Efficiency of the Dynamic Programming Algorithm

The proposed method addresses an NP-Hard problem. As such, one of the most important aspects of extending this method is to improve the efficiency of the algorithm. 

### Improving the Merge Order

In part 1, we discussed node partitions. For a given node, there are many, many possible partitions. This contributes heavily to the complexity of the algorithm. In part 2, we further extended these partitions to contain labels and omit edges, which makes the method even more combinatorially complex. 

The way the Dynamic Programming algorithm aims to relieve this complexity is by reducing the problem size iteratively. Given an input graph G, we merge two nodes at a time until the problem becomes trivially solvable. 

![Foto](/assets/merge-example.png){: width="500" }

The order for which we merge the nodes determines the complexity of the algorithm. If we follow a good merge order, the Dynamic Programming algorithm will run very quickly. If we follow a bad merge order, the Dynamic Programming algorithm might never finish! As such, it is crucial to find a good merging order. 

Unfortunately, the problem of finding the best merging order is also NP-Hard! Our current method finds a good initial merging order, and then iteratively improves it until convergence. However, it will easily get stuck in local optima. As such, there may be many potential ways of improving this method. 

### Improving Beam Search

Our approximate algorithm uses an idea called *beam search* in order to improve the efficiency of our algorithm. The general idea is that we have many possible ways to partition a given node. We can reduce this number by only keeping the top *k* partitions with the best cost for each node. Every time two nodes in our graph are merged, more partitions are discarded, as we only keep the top *k*. We will often times sacrifice the optimal solution by doing this, but the efficiency of the method will improve significantly. 

This method is very effective. However, there are many ways we can potentially improve it. For example, rather than keeping the top $k$ solutions, an adaptive beam search method could be implemented, with a "variable" size *k* that changes depending on one of many variables: like the cost distribution, the structure of adjacent nodes/partitions, etc. 

## Extending the Method, and Finding New Applications

Also, our DP algorithm may work for many cases not covered in this thesis. Many problems, such as minimum spanning tree, the traveling salesman problem, etc. can be addressed when using our algorithm on different input partitions. There are innumerable possibilities that can be addressed by the DP algorithm within and outside of biological structures, and thus many opportunities for novel research. 

Furthermore, the formulation itself can also be extended. While we address the challenges of merged nodes and redundant nodes/edges, there are also other potential challenges. For example, there may be cases where two branches cross or collide with each other across multiple points, and the skeletonization algorithm produces merged edges. This happens rarely in the cornroot dataset, where branches may collide with each other throughout multiple edges, this can be seen in the figure below: 

![Foto](/assets/merged-edges.png){: width="500" }

This may be addressed by assigning a "capacity" to each edge. A capacity-0 edge will be omitted, a capacity-1 edge will remain, a capacity-2 edge will be duplicated, and so on. 